# coding: utf-8

"""
    BioLink API

    API integration layer for linked biological objects.   __Source:__ https://github.com/monarch-initiative/biolink-api/

    OpenAPI spec version: 0.1.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class BioentityApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def get_allele_object(self, id, **kwargs):
        """
        TODO Returns allele object
        This is a composition of multiple smaller operations, including fetching allele metadata, plus allele associations  TODO - should allele be subsumed into variant?
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_allele_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Allele]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_allele_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_allele_object_with_http_info(id, **kwargs)
            return data

    def get_allele_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns allele object
        This is a composition of multiple smaller operations, including fetching allele metadata, plus allele associations  TODO - should allele be subsumed into variant?
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_allele_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Allele]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allele_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_allele_object`")


        collection_formats = {}

        resource_path = '/bioentity/allele/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Allele]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_anatomy_gene_associations(self, id, **kwargs):
        """
        TODO Returns associations between anatomical entity and genes
        Typically encompasses genes expressed in a particular location.  INFERENCE: part-of
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_anatomy_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_anatomy_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_anatomy_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_anatomy_gene_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations between anatomical entity and genes
        Typically encompasses genes expressed in a particular location.  INFERENCE: part-of
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_anatomy_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anatomy_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_anatomy_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/anatomy/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_anatomy_object(self, id, **kwargs):
        """
        TODO Returns anatomical entity
        Anatomical entities span ranges from the subcellular (e.g. nucleus) through cells to tissues, organs and organ systems.  When returning associations, inference over the appropriate relation will be used. For example, for gene expression, part-of will be used.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_anatomy_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of anatomical entity, e.g. GO:0005634 (nucleus), UBERON:0002037 (cerebellum), CL:0000540 (neuron). Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_anatomy_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_anatomy_object_with_http_info(id, **kwargs)
            return data

    def get_anatomy_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns anatomical entity
        Anatomical entities span ranges from the subcellular (e.g. nucleus) through cells to tissues, organs and organ systems.  When returning associations, inference over the appropriate relation will be used. For example, for gene expression, part-of will be used.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_anatomy_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of anatomical entity, e.g. GO:0005634 (nucleus), UBERON:0002037 (cerebellum), CL:0000540 (neuron). Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anatomy_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_anatomy_object`")


        collection_formats = {}

        resource_path = '/bioentity/anatomy/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_anatomy_phenotype_associations(self, id, **kwargs):
        """
        TODO Returns associations between anatomical entity and phenotypes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_anatomy_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_anatomy_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_anatomy_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_anatomy_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations between anatomical entity and phenotypes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_anatomy_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anatomy_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_anatomy_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/anatomy/{id}/phenotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_anatomy_associations(self, id, **kwargs):
        """
        TODO Returns anatomical locations associated with a disease
        For example, neurodegeneratibe disease located in nervous system. For cancer, this may include both site of original and end location.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_anatomy_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_anatomy_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_anatomy_associations_with_http_info(id, **kwargs)
            return data

    def get_disease_anatomy_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns anatomical locations associated with a disease
        For example, neurodegeneratibe disease located in nervous system. For cancer, this may include both site of original and end location.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_anatomy_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_anatomy_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_anatomy_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/anatomy/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_function_associations(self, id, **kwargs):
        """
        TODO Returns biological functions associated with a disease
        This may come from a combination of asserted knowledge (e.g. Fanconi Anemia affects DNA repair) or from data-driven approach (cf Translator)  Results are typically represented as GO classes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_function_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_function_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_function_associations_with_http_info(id, **kwargs)
            return data

    def get_disease_function_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns biological functions associated with a disease
        This may come from a combination of asserted knowledge (e.g. Fanconi Anemia affects DNA repair) or from data-driven approach (cf Translator)  Results are typically represented as GO classes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_function_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_function_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_function_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/function/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_gene_associations(self, id, **kwargs):
        """
        Returns genes associated with a disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_disease_gene_associations_with_http_info(self, id, **kwargs):
        """
        Returns genes associated with a disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_model_associations(self, id, **kwargs):
        """
        Returns associations to models of the disease
        In the association object returned, the subject will be the disease, and the object will be the model. The model may be a gene or genetic element.  If the query disease is a general class, the association subject may be to a specific disease.  In some cases the association will be *direct*, for example if a paper asserts a genotype is a model of a disease.  In other cases, the association will be *indirect*, for example, chaining over orthology. In these cases the chain will be reflected in the *evidence graph*  * TODO: provide hook into owlsim for dynamic computation of models by similarity
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_model_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_model_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_model_associations_with_http_info(id, **kwargs)
            return data

    def get_disease_model_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations to models of the disease
        In the association object returned, the subject will be the disease, and the object will be the model. The model may be a gene or genetic element.  If the query disease is a general class, the association subject may be to a specific disease.  In some cases the association will be *direct*, for example if a paper asserts a genotype is a model of a disease.  In other cases, the association will be *indirect*, for example, chaining over orthology. In these cases the chain will be reflected in the *evidence graph*  * TODO: provide hook into owlsim for dynamic computation of models by similarity
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_model_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_model_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_model_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/models/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_model_taxon_associations(self, id, taxon, **kwargs):
        """
        Same as `/disease/<id>/models` but constrain models by taxon
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_model_taxon_associations(id, taxon, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param str taxon: CURIE of organism taxonomy class to constrain models, e.g NCBITaxon:6239 (C elegans).   Higher level taxa may be used (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_model_taxon_associations_with_http_info(id, taxon, **kwargs)
        else:
            (data) = self.get_disease_model_taxon_associations_with_http_info(id, taxon, **kwargs)
            return data

    def get_disease_model_taxon_associations_with_http_info(self, id, taxon, **kwargs):
        """
        Same as `/disease/<id>/models` but constrain models by taxon
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_model_taxon_associations_with_http_info(id, taxon, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param str taxon: CURIE of organism taxonomy class to constrain models, e.g NCBITaxon:6239 (C elegans).   Higher level taxa may be used (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'taxon', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_model_taxon_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_model_taxon_associations`")
        # verify the required parameter 'taxon' is set
        if ('taxon' not in params) or (params['taxon'] is None):
            raise ValueError("Missing the required parameter `taxon` when calling `get_disease_model_taxon_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/models/{taxon}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'taxon' in params:
            path_params['taxon'] = params['taxon']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_object(self, id, **kwargs):
        """
        TODO Returns disease object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_object_with_http_info(id, **kwargs)
            return data

    def get_disease_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns disease object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_object`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_phenotype_associations(self, id, **kwargs):
        """
        Returns phenotypes associated with disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_disease_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns phenotypes associated with disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. OMIM:605543, DOID:678. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/phenotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_substance_associations(self, id, **kwargs):
        """
        Returns substances associated with a disease
        e.g. drugs or small molecules used to treat
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_substance_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. DOID:2841 (asthma). Equivalent IDs not yet supported (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_substance_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_substance_associations_with_http_info(id, **kwargs)
            return data

    def get_disease_substance_associations_with_http_info(self, id, **kwargs):
        """
        Returns substances associated with a disease
        e.g. drugs or small molecules used to treat
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_substance_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of disease, e.g. DOID:2841 (asthma). Equivalent IDs not yet supported (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_substance_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_substance_associations`")


        collection_formats = {}

        resource_path = '/bioentity/disease/{id}/substance/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disease_substance_associations_0(self, id, **kwargs):
        """
        Returns substances associated with a disease
        e.g. drugs or small molecules used to treat
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_substance_associations_0(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_disease_substance_associations_0_with_http_info(id, **kwargs)
        else:
            (data) = self.get_disease_substance_associations_0_with_http_info(id, **kwargs)
            return data

    def get_disease_substance_associations_0_with_http_info(self, id, **kwargs):
        """
        Returns substances associated with a disease
        e.g. drugs or small molecules used to treat
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_disease_substance_associations_0_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disease_substance_associations_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_disease_substance_associations_0`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/treats/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_environment_object(self, id, **kwargs):
        """
        TODO Returns environment entity
        TODO consider renaming exposure
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_environment_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_environment_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_environment_object_with_http_info(id, **kwargs)
            return data

    def get_environment_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns environment entity
        TODO consider renaming exposure
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_environment_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_environment_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_environment_object`")


        collection_formats = {}

        resource_path = '/bioentity/environment/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_environment_phenotype_associations(self, id, **kwargs):
        """
        TODO Returns list of associations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_environment_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_environment_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_environment_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_environment_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns list of associations
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_environment_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_environment_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_environment_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/environment/{id}/phenotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_disease_associations(self, id, **kwargs):
        """
        Returns diseases associated with gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_disease_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750, Orphanet:173505. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_disease_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_disease_associations_with_http_info(id, **kwargs)
            return data

    def get_gene_disease_associations_with_http_info(self, id, **kwargs):
        """
        Returns diseases associated with gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_disease_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750, Orphanet:173505. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_disease_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_disease_associations`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/diseases/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_expression_associations(self, id, **kwargs):
        """
        TODO Returns expression events for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_expression_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_expression_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_expression_associations_with_http_info(id, **kwargs)
            return data

    def get_gene_expression_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns expression events for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_expression_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_expression_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_expression_associations`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/expressed/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_function_associations(self, id, **kwargs):
        """
        Returns function associations for a gene
        IMPLEMENTATION DETAILS ----------------------  Note: currently this is implemented as a query to the GO/AmiGO solr instance. This directly supports IDs such as:   - ZFIN e.g. ZFIN:ZDB-GENE-050417-357  Note that the AmiGO GOlr natively stores MGI annotations to MGI:MGI:nn. However, the standard for biolink is MGI:nnnn, so you should use this (will be transparently mapped to legacy ID)  Additionally, for some species such as Human, GO has the annotation attached to the UniProt ID. Again, this should be transparently handled; e.g. you can use NCBIGene:6469, and this will be mapped behind the scenes for querying.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_function_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:3630. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param str homology_type: P, O or LDO (paralog, ortholog or least-diverged).
        :param str homolog_taxon: Taxon CURIE of homolog, e.g. NCBITaxon:9606. Can be intermediate note, includes inferred by default
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_function_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_function_associations_with_http_info(id, **kwargs)
            return data

    def get_gene_function_associations_with_http_info(self, id, **kwargs):
        """
        Returns function associations for a gene
        IMPLEMENTATION DETAILS ----------------------  Note: currently this is implemented as a query to the GO/AmiGO solr instance. This directly supports IDs such as:   - ZFIN e.g. ZFIN:ZDB-GENE-050417-357  Note that the AmiGO GOlr natively stores MGI annotations to MGI:MGI:nn. However, the standard for biolink is MGI:nnnn, so you should use this (will be transparently mapped to legacy ID)  Additionally, for some species such as Human, GO has the annotation attached to the UniProt ID. Again, this should be transparently handled; e.g. you can use NCBIGene:6469, and this will be mapped behind the scenes for querying.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_function_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:3630. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param str homology_type: P, O or LDO (paralog, ortholog or least-diverged).
        :param str homolog_taxon: Taxon CURIE of homolog, e.g. NCBITaxon:9606. Can be intermediate note, includes inferred by default
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'homology_type', 'homolog_taxon', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_function_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_function_associations`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/function/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'homology_type' in params:
            query_params['homology_type'] = params['homology_type']
        if 'homolog_taxon' in params:
            query_params['homolog_taxon'] = params['homolog_taxon']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_homolog_associations(self, id, **kwargs):
        """
        Returns homologs for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_homolog_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:3630. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param str homology_type: P, O or LDO (paralog, ortholog or least-diverged).
        :param str homolog_taxon: Taxon CURIE of homolog, e.g. NCBITaxon:9606. Can be intermediate note, includes inferred by default
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_homolog_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_homolog_associations_with_http_info(id, **kwargs)
            return data

    def get_gene_homolog_associations_with_http_info(self, id, **kwargs):
        """
        Returns homologs for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_homolog_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:3630. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param str homology_type: P, O or LDO (paralog, ortholog or least-diverged).
        :param str homolog_taxon: Taxon CURIE of homolog, e.g. NCBITaxon:9606. Can be intermediate note, includes inferred by default
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'homology_type', 'homolog_taxon', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_homolog_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_homolog_associations`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/homologs/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'homology_type' in params:
            query_params['homology_type'] = params['homology_type']
        if 'homolog_taxon' in params:
            query_params['homolog_taxon'] = params['homolog_taxon']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_interactions(self, id, **kwargs):
        """
        Returns interactions for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_interactions(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:3630. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_interactions_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_interactions_with_http_info(id, **kwargs)
            return data

    def get_gene_interactions_with_http_info(self, id, **kwargs):
        """
        Returns interactions for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_interactions_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:3630. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_interactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_interactions`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/interactions/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_object(self, id, **kwargs):
        """
        Returns gene object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:84570 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Gene]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_object_with_http_info(id, **kwargs)
            return data

    def get_gene_object_with_http_info(self, id, **kwargs):
        """
        Returns gene object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:84570 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Gene]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_object`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Gene]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_phenotype_associations(self, id, **kwargs):
        """
        Returns phenotypes associated with gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_gene_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns phenotypes associated with gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/phenotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_gene_publication_list(self, id, **kwargs):
        """
        TODO Returns expression events for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_publication_list(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_gene_publication_list_with_http_info(id, **kwargs)
        else:
            (data) = self.get_gene_publication_list_with_http_info(id, **kwargs)
            return data

    def get_gene_publication_list_with_http_info(self, id, **kwargs):
        """
        TODO Returns expression events for a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_gene_publication_list_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of gene, e.g. NCBIGene:4750. Equivalent IDs can be used with same results (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_gene_publication_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_gene_publication_list`")


        collection_formats = {}

        resource_path = '/bioentity/gene/{id}/pubs/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_geneproduct_object(self, id, **kwargs):
        """
        TODO Returns gene product object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_geneproduct_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_geneproduct_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_geneproduct_object_with_http_info(id, **kwargs)
            return data

    def get_geneproduct_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns gene product object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_geneproduct_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_geneproduct_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_geneproduct_object`")


        collection_formats = {}

        resource_path = '/bioentity/geneproduct/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_generic_associations(self, id, **kwargs):
        """
        Returns associations for an entity regardless of the type
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_generic_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_generic_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_generic_associations_with_http_info(id, **kwargs)
            return data

    def get_generic_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations for an entity regardless of the type
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_generic_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_generic_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_generic_associations`")


        collection_formats = {}

        resource_path = '/bioentity/{id}/associations/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_generic_object(self, id, **kwargs):
        """
        TODO Returns object of any type
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_generic_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:84570 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[BioObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_generic_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_generic_object_with_http_info(id, **kwargs)
            return data

    def get_generic_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns object of any type
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_generic_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: id, e.g. NCBIGene:84570 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[BioObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_generic_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_generic_object`")


        collection_formats = {}

        resource_path = '/bioentity/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[BioObject]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_genotype_disease_associations(self, id, **kwargs):
        """
        Returns diseases associated with a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_disease_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-4286 (if non-human will return models) (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_genotype_disease_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_genotype_disease_associations_with_http_info(id, **kwargs)
            return data

    def get_genotype_disease_associations_with_http_info(self, id, **kwargs):
        """
        Returns diseases associated with a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_disease_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-4286 (if non-human will return models) (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_genotype_disease_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_genotype_disease_associations`")


        collection_formats = {}

        resource_path = '/bioentity/genotype/{id}/diseases/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_genotype_gene_associations(self, id, **kwargs):
        """
        Returns genes associated with a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-6607 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_genotype_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_genotype_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_genotype_gene_associations_with_http_info(self, id, **kwargs):
        """
        Returns genes associated with a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-6607 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_genotype_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_genotype_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/genotype/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_genotype_genotype_associations(self, id, **kwargs):
        """
        Returns genotypes-genotype associations
        Genotypes may be related to one another according to the GENO model
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_genotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-6607 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_genotype_genotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_genotype_genotype_associations_with_http_info(id, **kwargs)
            return data

    def get_genotype_genotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns genotypes-genotype associations
        Genotypes may be related to one another according to the GENO model
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_genotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-6607 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_genotype_genotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_genotype_genotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/genotype/{id}/genotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_genotype_object(self, id, **kwargs):
        """
        Returns genotype object
        The genotype object will have the following association sets populated:   * gene  * phenotype  * disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-6607 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Genotype]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_genotype_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_genotype_object_with_http_info(id, **kwargs)
            return data

    def get_genotype_object_with_http_info(self, id, **kwargs):
        """
        Returns genotype object
        The genotype object will have the following association sets populated:   * gene  * phenotype  * disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-6607 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Genotype]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_genotype_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_genotype_object`")


        collection_formats = {}

        resource_path = '/bioentity/genotype/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Genotype]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_genotype_phenotype_associations(self, id, **kwargs):
        """
        Returns phenotypes associated with a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-4286 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_genotype_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_genotype_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_genotype_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns phenotypes associated with a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_genotype_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of genotype, e.g. ZFIN:ZDB-FISH-150901-4286 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_genotype_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_genotype_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/genotype/{id}/phenotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_goterm_gene_associations(self, id, **kwargs):
        """
        TODO Returns associated genes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_goterm_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_goterm_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_goterm_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_goterm_gene_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associated genes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_goterm_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goterm_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_goterm_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/goterm/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_goterm_object(self, id, **kwargs):
        """
        TODO Returns GO class object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_goterm_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: GO class CURIE identifier, e.g GO:0016301 (kinase activity) (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_goterm_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_goterm_object_with_http_info(id, **kwargs)
            return data

    def get_goterm_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns GO class object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_goterm_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: GO class CURIE identifier, e.g GO:0016301 (kinase activity) (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goterm_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_goterm_object`")


        collection_formats = {}

        resource_path = '/bioentity/goterm/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_goterm_phenotype_associations(self, id, **kwargs):
        """
        TODO Returns associated phenotypes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_goterm_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_goterm_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_goterm_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_goterm_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associated phenotypes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_goterm_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goterm_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_goterm_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/goterm/{id}/phenotype/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_literature_disease_associations(self, id, **kwargs):
        """
        Returns associations between a lit entity and a disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_literature_disease_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_literature_disease_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_literature_disease_associations_with_http_info(id, **kwargs)
            return data

    def get_literature_disease_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations between a lit entity and a disease
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_literature_disease_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_literature_disease_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_literature_disease_associations`")


        collection_formats = {}

        resource_path = '/bioentity/literature/{id}/diseases/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_literature_gene_associations(self, id, **kwargs):
        """
        Returns associations between a lit entity and a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_literature_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_literature_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_literature_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_literature_gene_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations between a lit entity and a gene
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_literature_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_literature_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_literature_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/literature/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_literature_genotype_associations(self, id, **kwargs):
        """
        Returns associations between a lit entity and a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_literature_genotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_literature_genotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_literature_genotype_associations_with_http_info(id, **kwargs)
            return data

    def get_literature_genotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations between a lit entity and a genotype
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_literature_genotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_literature_genotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_literature_genotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/literature/{id}/genotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_parent_object(self, id, **kwargs):
        """
        TODO Returns individual
        Individuals may typically encompass patients, but can be individuals of any species
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_parent_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_parent_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_parent_object_with_http_info(id, **kwargs)
            return data

    def get_parent_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns individual
        Individuals may typically encompass patients, but can be individuals of any species
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_parent_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parent_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_parent_object`")


        collection_formats = {}

        resource_path = '/bioentity/individual/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_parent_object_0(self, id, **kwargs):
        """
        TODO Returns investigation object
        Investigations encompass clinical trials, molecular biology experiments or any kind of study
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_parent_object_0(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_parent_object_0_with_http_info(id, **kwargs)
        else:
            (data) = self.get_parent_object_0_with_http_info(id, **kwargs)
            return data

    def get_parent_object_0_with_http_info(self, id, **kwargs):
        """
        TODO Returns investigation object
        Investigations encompass clinical trials, molecular biology experiments or any kind of study
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_parent_object_0_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parent_object_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_parent_object_0`")


        collection_formats = {}

        resource_path = '/bioentity/investigation/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pathway_gene_associations(self, id, **kwargs):
        """
        TODO Returns list of genes associated with a pathway
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pathway_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pathway_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_pathway_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_pathway_gene_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns list of genes associated with a pathway
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pathway_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pathway_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_pathway_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/pathway/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pathway_object(self, id, **kwargs):
        """
        TODO Returns pathway object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pathway_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE any pathway element. May be a GO ID or a pathway database ID (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pathway_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_pathway_object_with_http_info(id, **kwargs)
            return data

    def get_pathway_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns pathway object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pathway_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE any pathway element. May be a GO ID or a pathway database ID (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pathway_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_pathway_object`")


        collection_formats = {}

        resource_path = '/bioentity/pathway/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pathway_participant_associations(self, id, **kwargs):
        """
        TODO Returns associations to participants (molecules, etc) for a pathway
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pathway_participant_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pathway_participant_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_pathway_participant_associations_with_http_info(id, **kwargs)
            return data

    def get_pathway_participant_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations to participants (molecules, etc) for a pathway
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pathway_participant_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pathway_participant_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_pathway_participant_associations`")


        collection_formats = {}

        resource_path = '/bioentity/pathway/{id}/participants/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_phenotype_anatomy_associations(self, id, **kwargs):
        """
        Returns anatomical entities associated with a phenotype
        Example IDs:   * ZP:0004204   * MP:0008521 abnormal Bowman membrane  For example, *abnormal limb development* will map to *limb*
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_anatomy_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[NamedObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_phenotype_anatomy_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_phenotype_anatomy_associations_with_http_info(id, **kwargs)
            return data

    def get_phenotype_anatomy_associations_with_http_info(self, id, **kwargs):
        """
        Returns anatomical entities associated with a phenotype
        Example IDs:   * ZP:0004204   * MP:0008521 abnormal Bowman membrane  For example, *abnormal limb development* will map to *limb*
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_anatomy_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[NamedObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_phenotype_anatomy_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_phenotype_anatomy_associations`")


        collection_formats = {}

        resource_path = '/bioentity/phenotype/{id}/anatomy/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[NamedObject]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_phenotype_function_associations(self, id, **kwargs):
        """
        TODO Returns biological functions associated with a Phenotype
        This may come from a combination of asserted knowledge (e.g. abnormal levels of metabolite to corresponding GO activity) or from data-driven approach (cf Translator)  Results are typically represented as GO classes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_function_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_phenotype_function_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_phenotype_function_associations_with_http_info(id, **kwargs)
            return data

    def get_phenotype_function_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns biological functions associated with a Phenotype
        This may come from a combination of asserted knowledge (e.g. abnormal levels of metabolite to corresponding GO activity) or from data-driven approach (cf Translator)  Results are typically represented as GO classes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_function_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_phenotype_function_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_phenotype_function_associations`")


        collection_formats = {}

        resource_path = '/bioentity/phenotype/{id}/function/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_phenotype_gene_associations(self, id, taxid, **kwargs):
        """
        Returns gene ids for all genes for a particular phenotype in a taxon
        For example, + NCBITaxon:10090 (mouse)
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_gene_associations(id, taxid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Pheno class CURIE identifier, e.g  MP:0001569 (abnormal circulating bilirubin level) (required)
        :param str taxid: Species or high level taxon grouping, e.g  NCBITaxon:10090 (Mus musculus) (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_phenotype_gene_associations_with_http_info(id, taxid, **kwargs)
        else:
            (data) = self.get_phenotype_gene_associations_with_http_info(id, taxid, **kwargs)
            return data

    def get_phenotype_gene_associations_with_http_info(self, id, taxid, **kwargs):
        """
        Returns gene ids for all genes for a particular phenotype in a taxon
        For example, + NCBITaxon:10090 (mouse)
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_gene_associations_with_http_info(id, taxid, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: Pheno class CURIE identifier, e.g  MP:0001569 (abnormal circulating bilirubin level) (required)
        :param str taxid: Species or high level taxon grouping, e.g  NCBITaxon:10090 (Mus musculus) (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'taxid', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_phenotype_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_phenotype_gene_associations`")
        # verify the required parameter 'taxid' is set
        if ('taxid' not in params) or (params['taxid'] is None):
            raise ValueError("Missing the required parameter `taxid` when calling `get_phenotype_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/phenotype/{id}/gene/{taxid}/ids'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'taxid' in params:
            path_params['taxid'] = params['taxid']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_phenotype_gene_associations_0(self, id, **kwargs):
        """
        TODO Returns associated phenotypes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_gene_associations_0(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_phenotype_gene_associations_0_with_http_info(id, **kwargs)
        else:
            (data) = self.get_phenotype_gene_associations_0_with_http_info(id, **kwargs)
            return data

    def get_phenotype_gene_associations_0_with_http_info(self, id, **kwargs):
        """
        TODO Returns associated phenotypes
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_gene_associations_0_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_phenotype_gene_associations_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_phenotype_gene_associations_0`")


        collection_formats = {}

        resource_path = '/bioentity/phenotype/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_phenotype_object(self, id, **kwargs):
        """
        TODO Returns phenotype class object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_phenotype_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_phenotype_object_with_http_info(id, **kwargs)
            return data

    def get_phenotype_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns phenotype class object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_phenotype_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_phenotype_object`")


        collection_formats = {}

        resource_path = '/bioentity/phenotype/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_phenotype_phenotype_associations(self, id, **kwargs):
        """
        TODO Returns associated phenotypes
        Includes phenologs, as well as equivalent phenotypes in other species
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_phenotype_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_phenotype_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_phenotype_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associated phenotypes
        Includes phenologs, as well as equivalent phenotypes in other species
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_phenotype_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_phenotype_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_phenotype_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/phenotype/{id}/phenotype/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pub_object(self, id, **kwargs):
        """
        TODO Returns publication object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pub_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pub_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_pub_object_with_http_info(id, **kwargs)
            return data

    def get_pub_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns publication object
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pub_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pub_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_pub_object`")


        collection_formats = {}

        resource_path = '/bioentity/literature/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_sequence_feature_object(self, id, **kwargs):
        """
        TODO Returns seqfeature
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_sequence_feature_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_sequence_feature_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_sequence_feature_object_with_http_info(id, **kwargs)
            return data

    def get_sequence_feature_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns seqfeature
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_sequence_feature_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sequence_feature_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sequence_feature_object`")


        collection_formats = {}

        resource_path = '/bioentity/sequence_feature/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_exposures(self, id, **kwargs):
        """
        TODO Returns associations between a substance and related exposures
        E.g. between pesticide and occupational exposure class
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_exposures(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_exposures_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_exposures_with_http_info(id, **kwargs)
            return data

    def get_substance_exposures_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations between a substance and related exposures
        E.g. between pesticide and occupational exposure class
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_exposures_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_exposures" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_exposures`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/exposures/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_interactions(self, id, **kwargs):
        """
        TODO Returns associations between given drug and interactions
        Interactions can encompass drugs or environments
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_interactions(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_interactions_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_interactions_with_http_info(id, **kwargs)
            return data

    def get_substance_interactions_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations between given drug and interactions
        Interactions can encompass drugs or environments
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_interactions_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_interactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_interactions`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/interactions/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_object(self, id, **kwargs):
        """
        TODO Returns substance entity
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Substance]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_object_with_http_info(id, **kwargs)
            return data

    def get_substance_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns substance entity
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Substance]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_object`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Substance]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_participant_in_associations(self, id, **kwargs):
        """
        Returns associations between an activity and process and the specified substance
        Examples relationships:   * substance is a metabolite of a process  * substance is synthesized by a process  * substance is modified by an activity  * substance elicits a response program/pathway  * substance is transported by activity or pathway  For example, CHEBI:40036 (amitrole)
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_participant_in_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_participant_in_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_participant_in_associations_with_http_info(id, **kwargs)
            return data

    def get_substance_participant_in_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations between an activity and process and the specified substance
        Examples relationships:   * substance is a metabolite of a process  * substance is synthesized by a process  * substance is modified by an activity  * substance elicits a response program/pathway  * substance is transported by activity or pathway  For example, CHEBI:40036 (amitrole)
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_participant_in_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_participant_in_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_participant_in_associations`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/participant_in/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_relationships(self, id, **kwargs):
        """
        TODO Returns associations between a substance and other substances
        E.g. metabolite-of, tautomer-of, parent-of, ...
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_relationships(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_relationships_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_relationships_with_http_info(id, **kwargs)
            return data

    def get_substance_relationships_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations between a substance and other substances
        E.g. metabolite-of, tautomer-of, parent-of, ...
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_relationships_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_relationships" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_relationships`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/substances/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_role_associations(self, id, **kwargs):
        """
        Returns associations between given drug and roles
        Roles may be human-oriented (e.g. pesticide) or molecular (e.g. enzyme inhibitor)
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_role_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_role_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_role_associations_with_http_info(id, **kwargs)
            return data

    def get_substance_role_associations_with_http_info(self, id, **kwargs):
        """
        Returns associations between given drug and roles
        Roles may be human-oriented (e.g. pesticide) or molecular (e.g. enzyme inhibitor)
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_role_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_role_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_role_associations`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/roles/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_substance_target_associations(self, id, **kwargs):
        """
        TODO Returns associations between given drug and targets
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_target_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_substance_target_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_substance_target_associations_with_http_info(id, **kwargs)
            return data

    def get_substance_target_associations_with_http_info(self, id, **kwargs):
        """
        TODO Returns associations between given drug and targets
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_substance_target_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: list[Association]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_substance_target_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_substance_target_associations`")


        collection_formats = {}

        resource_path = '/bioentity/substance/{id}/targets/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Association]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_variant_gene_associations(self, id, **kwargs):
        """
        Returns genes associated with a variant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_gene_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_variant_gene_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_variant_gene_associations_with_http_info(id, **kwargs)
            return data

    def get_variant_gene_associations_with_http_info(self, id, **kwargs):
        """
        Returns genes associated with a variant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_gene_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_variant_gene_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_variant_gene_associations`")


        collection_formats = {}

        resource_path = '/bioentity/variant/{id}/genes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_variant_genotype_associations(self, id, **kwargs):
        """
        Returns genotypes associated with a variant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_genotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_variant_genotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_variant_genotype_associations_with_http_info(id, **kwargs)
            return data

    def get_variant_genotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns genotypes associated with a variant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_genotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_variant_genotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_variant_genotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/variant/{id}/genotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_variant_object(self, id, **kwargs):
        """
        TODO Returns sequence variant entity
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_object(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_variant_object_with_http_info(id, **kwargs)
        else:
            (data) = self.get_variant_object_with_http_info(id, **kwargs)
            return data

    def get_variant_object_with_http_info(self, id, **kwargs):
        """
        TODO Returns sequence variant entity
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_object_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_variant_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_variant_object`")


        collection_formats = {}

        resource_path = '/bioentity/variant/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_variant_phenotype_associations(self, id, **kwargs):
        """
        Returns phenotypes associated with a variant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_phenotype_associations(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_variant_phenotype_associations_with_http_info(id, **kwargs)
        else:
            (data) = self.get_variant_phenotype_associations_with_http_info(id, **kwargs)
            return data

    def get_variant_phenotype_associations_with_http_info(self, id, **kwargs):
        """
        Returns phenotypes associated with a variant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_variant_phenotype_associations_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: CURIE identifier of variant, e.g. ZFIN:ZDB-ALT-010427-8, ClinVarVariant:39783 (required)
        :param bool use_compact_associations: If true, returns results in compact associations format
        :param bool unselect_evidence: If set, excludes evidence objects in response
        :param bool exclude_automatic_assertions: If set, excludes associations that involve IEAs (ECO:0000501)
        :param list[str] slim: Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID
        :param int rows: number of rows
        :param str evidence: Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)                     or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.                     
        :param bool fetch_objects: If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload
        :return: AssociationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'use_compact_associations', 'unselect_evidence', 'exclude_automatic_assertions', 'slim', 'rows', 'evidence', 'fetch_objects']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_variant_phenotype_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_variant_phenotype_associations`")


        collection_formats = {}

        resource_path = '/bioentity/variant/{id}/phenotypes/'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}
        if 'use_compact_associations' in params:
            query_params['use_compact_associations'] = params['use_compact_associations']
        if 'unselect_evidence' in params:
            query_params['unselect_evidence'] = params['unselect_evidence']
        if 'exclude_automatic_assertions' in params:
            query_params['exclude_automatic_assertions'] = params['exclude_automatic_assertions']
        if 'slim' in params:
            query_params['slim'] = params['slim']
            collection_formats['slim'] = 'multi'
        if 'rows' in params:
            query_params['rows'] = params['rows']
        if 'evidence' in params:
            query_params['evidence'] = params['evidence']
        if 'fetch_objects' in params:
            query_params['fetch_objects'] = params['fetch_objects']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AssociationResults',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
